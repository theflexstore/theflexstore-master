// Generated by CoffeeScript 1.12.3
(function() {
  var AWS, Buffer, Stream, helpers;

  helpers = require('../helpers');

  AWS = helpers.AWS;

  Stream = AWS.util.stream;

  Buffer = AWS.util.Buffer;

  describe('AWS.S3', function() {
    var request, s3;
    s3 = null;
    request = function(operation, params) {
      return s3.makeRequest(operation, params);
    };
    beforeEach(function(done) {
      s3 = new AWS.S3({
        region: void 0
      });
      s3.clearBucketRegionCache();
      return done();
    });
    describe('dnsCompatibleBucketName', function() {
      it('must be at least 3 characters', function() {
        return expect(s3.dnsCompatibleBucketName('aa')).to.equal(false);
      });
      it('must not be longer than 63 characters', function() {
        var b;
        b = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
        return expect(s3.dnsCompatibleBucketName(b)).to.equal(false);
      });
      it('must start with a lower-cased letter or number', function() {
        expect(s3.dnsCompatibleBucketName('Abc')).to.equal(false);
        expect(s3.dnsCompatibleBucketName('-bc')).to.equal(false);
        return expect(s3.dnsCompatibleBucketName('abc')).to.equal(true);
      });
      it('must end with a lower-cased letter or number', function() {
        expect(s3.dnsCompatibleBucketName('abC')).to.equal(false);
        expect(s3.dnsCompatibleBucketName('ab-')).to.equal(false);
        return expect(s3.dnsCompatibleBucketName('abc')).to.equal(true);
      });
      it('may not contain multiple contiguous dots', function() {
        expect(s3.dnsCompatibleBucketName('abc.123')).to.equal(true);
        return expect(s3.dnsCompatibleBucketName('abc..123')).to.equal(false);
      });
      it('may only contain letters numbers and dots', function() {
        expect(s3.dnsCompatibleBucketName('abc123')).to.equal(true);
        return expect(s3.dnsCompatibleBucketName('abc_123')).to.equal(false);
      });
      return it('must not look like an ip address', function() {
        expect(s3.dnsCompatibleBucketName('1.2.3.4')).to.equal(false);
        return expect(s3.dnsCompatibleBucketName('a.b.c.d')).to.equal(true);
      });
    });
    describe('constructor', function() {
      return it('requires endpoint if s3BucketEndpoint is passed', function() {
        return expect(function() {
          return new AWS.S3({
            s3BucketEndpoint: true
          });
        }).to["throw"](/An endpoint must be provided/);
      });
    });
    describe('endpoint', function() {
      it('sets hostname to s3.amazonaws.com when region is un-specified', function() {
        s3 = new AWS.S3({
          region: void 0
        });
        return expect(s3.endpoint.hostname).to.equal('s3.amazonaws.com');
      });
      it('sets hostname to s3.amazonaws.com when region is us-east-1', function() {
        s3 = new AWS.S3({
          region: 'us-east-1'
        });
        return expect(s3.endpoint.hostname).to.equal('s3.amazonaws.com');
      });
      it('sets region to us-east-1 when unspecified', function() {
        s3 = new AWS.S3({
          region: 'us-east-1'
        });
        return expect(s3.config.region).to.equal('us-east-1');
      });
      it('combines the region with s3 in the endpoint using a - instead of .', function() {
        s3 = new AWS.S3({
          region: 'us-west-1'
        });
        return expect(s3.endpoint.hostname).to.equal('s3-us-west-1.amazonaws.com');
      });
      return it('sets a region-specific dualstack endpoint when dualstack enabled', function() {
        s3 = new AWS.S3({
          region: 'us-west-1',
          useDualstack: true
        });
        expect(s3.endpoint.hostname).to.equal('s3.dualstack.us-west-1.amazonaws.com');
        s3 = new AWS.S3({
          region: 'us-east-1',
          useDualstack: true
        });
        return expect(s3.endpoint.hostname).to.equal('s3.dualstack.us-east-1.amazonaws.com');
      });
    });
    describe('clearing bucket region cache', function() {
      beforeEach(function() {
        return s3.bucketRegionCache = {
          a: 'rg-fake-1',
          b: 'rg-fake-2',
          c: 'rg-fake-3'
        };
      });
      it('clears one bucket name', function() {
        s3.clearBucketRegionCache('b');
        return expect(s3.bucketRegionCache).to.eql({
          a: 'rg-fake-1',
          c: 'rg-fake-3'
        });
      });
      it('clears a list of bucket names', function() {
        s3.clearBucketRegionCache(['a', 'c']);
        return expect(s3.bucketRegionCache).to.eql({
          b: 'rg-fake-2'
        });
      });
      return it('clears entire cache', function() {
        s3.clearBucketRegionCache();
        return expect(s3.bucketRegionCache).to.eql({});
      });
    });
    describe('getSignerClass', function() {
      var getVersion;
      getVersion = function(signer) {
        if (signer === AWS.Signers.S3) {
          return 's3';
        } else if (signer === AWS.Signers.V4) {
          return 'v4';
        } else if (signer === AWS.Signers.V2) {
          return 'v2';
        }
      };
      describe('when using presigned requests', function() {
        var req;
        req = null;
        beforeEach(function(done) {
          req = request('mock');
          helpers.spyOn(req, 'isPresigned').andReturn(true);
          return done();
        });
        describe('will return an s3 (v2) signer when', function() {
          it('user does not specify a signatureVersion for a region that supports v2', function(done) {
            s3 = new AWS.S3({
              region: 'us-east-1'
            });
            expect(getVersion(s3.getSignerClass(req))).to.equal('s3');
            return done();
          });
          it('user specifies a signatureVersion of s3', function(done) {
            s3 = new AWS.S3({
              signatureVersion: 's3'
            });
            expect(getVersion(s3.getSignerClass(req))).to.equal('s3');
            return done();
          });
          return it('user specifies a signatureVersion of v2', function(done) {
            s3 = new AWS.S3({
              signatureVersion: 'v2'
            });
            expect(getVersion(s3.getSignerClass(req))).to.equal('s3');
            return done();
          });
        });
        return describe('will return a v4 signer when', function() {
          it('user does not specify a signatureVersion for a region that supports only v4', function(done) {
            s3 = new AWS.S3({
              region: 'eu-central-1'
            });
            expect(getVersion(s3.getSignerClass(req))).to.equal('v4');
            return done();
          });
          return it('user specifies a signatureVersion of v4', function(done) {
            s3 = new AWS.S3({
              signatureVersion: 'v4'
            });
            expect(getVersion(s3.getSignerClass(req))).to.equal('v4');
            return done();
          });
        });
      });
      return describe('when not using presigned requests', function() {
        describe('will return an s3 (v2) signer when', function() {
          it('user specifies a signatureVersion of s3', function(done) {
            s3 = new AWS.S3({
              signatureVersion: 's3'
            });
            expect(getVersion(s3.getSignerClass())).to.equal('s3');
            return done();
          });
          it('user specifies a signatureVersion of v2', function(done) {
            s3 = new AWS.S3({
              signatureVersion: 'v2'
            });
            expect(getVersion(s3.getSignerClass())).to.equal('s3');
            return done();
          });
          return it('user does not specify a signatureVersion and region supports v2', function(done) {
            s3 = new AWS.S3({
              region: 'us-east-1'
            });
            expect(getVersion(s3.getSignerClass())).to.equal('s3');
            return done();
          });
        });
        return describe('will return a v4 signer when', function() {
          it('user does not specify a signatureVersion and region only supports v4', function(done) {
            s3 = new AWS.S3({
              region: 'eu-central-1'
            });
            expect(getVersion(s3.getSignerClass())).to.equal('v4');
            return done();
          });
          return it('user specifies a signatureVersion of v4', function(done) {
            s3 = new AWS.S3({
              signatureVersion: 'v4'
            });
            expect(getVersion(s3.getSignerClass())).to.equal('v4');
            return done();
          });
        });
      });
    });
    describe('building a request', function() {
      var build;
      build = function(operation, params) {
        return request(operation, params).build().httpRequest;
      };
      it('obeys the configuration for s3ForcePathStyle', function() {
        var config, req;
        config = new AWS.Config({
          s3ForcePathStyle: true,
          accessKeyId: 'AKID',
          secretAccessKey: 'SECRET'
        });
        s3 = new AWS.S3(config);
        expect(s3.config.s3ForcePathStyle).to.equal(true);
        req = build('headObject', {
          Bucket: 'bucket',
          Key: 'key'
        });
        expect(req.endpoint.hostname).to.equal('s3.amazonaws.com');
        return expect(req.path).to.equal('/bucket/key');
      });
      it('does not enable path style if endpoint is a bucket', function() {
        var req;
        s3 = new AWS.S3({
          endpoint: 'foo.bar',
          s3BucketEndpoint: true
        });
        req = build('listObjects', {
          Bucket: 'bucket'
        });
        expect(req.endpoint.hostname).to.equal('foo.bar');
        expect(req.path).to.equal('/');
        return expect(req.virtualHostedBucket).to.equal('bucket');
      });
      it('allows user override if an endpoint is specified', function() {
        var req;
        s3 = new AWS.S3({
          endpoint: 'foo.bar',
          s3ForcePathStyle: true
        });
        req = build('listObjects', {
          Bucket: 'bucket'
        });
        expect(req.endpoint.hostname).to.equal('foo.bar');
        return expect(req.path).to.equal('/bucket');
      });
      it('does not allow non-bucket operations with s3BucketEndpoint set', function() {
        var req;
        s3 = new AWS.S3({
          endpoint: 'foo.bar',
          s3BucketEndpoint: true,
          paramValidation: true
        });
        req = s3.listBuckets().build();
        return expect(req.response.error.code).to.equal('ConfigError');
      });
      it('corrects virtual-hosted bucket region on request if bucket region stored in cache', function() {
        var httpRequest, param, req;
        s3 = new AWS.S3({
          region: 'us-east-1'
        });
        s3.bucketRegionCache.name = 'us-west-2';
        param = {
          Bucket: 'name'
        };
        req = s3.headBucket(param).build();
        httpRequest = req.httpRequest;
        expect(httpRequest.region).to.equal('us-west-2');
        expect(httpRequest.endpoint.hostname).to.equal('name.s3-us-west-2.amazonaws.com');
        expect(httpRequest.headers.Host).to.equal('name.s3-us-west-2.amazonaws.com');
        return expect(httpRequest.path).to.equal('/');
      });
      it('corrects path-style bucket region on request if bucket region stored in cache', function() {
        var httpRequest, param, req;
        s3 = new AWS.S3({
          region: 'us-east-1',
          s3ForcePathStyle: true
        });
        s3.bucketRegionCache.name = 'us-west-2';
        param = {
          Bucket: 'name'
        };
        req = s3.headBucket(param).build();
        httpRequest = req.httpRequest;
        expect(httpRequest.region).to.equal('us-west-2');
        expect(httpRequest.endpoint.hostname).to.equal('s3-us-west-2.amazonaws.com');
        expect(httpRequest.headers.Host).to.equal('s3-us-west-2.amazonaws.com');
        return expect(httpRequest.path).to.equal('/name');
      });
      describe('with useAccelerateEndpoint set to true', function() {
        beforeEach(function() {
          return s3 = new AWS.S3({
            useAccelerateEndpoint: true
          });
        });
        it('changes the hostname to use s3-accelerate for dns-comaptible buckets', function() {
          var req;
          req = build('getObject', {
            Bucket: 'foo',
            Key: 'bar'
          });
          return expect(req.endpoint.hostname).to.equal('foo.s3-accelerate.amazonaws.com');
        });
        it('overrides s3BucketEndpoint configuration when s3BucketEndpoint is set', function() {
          var req;
          s3 = new AWS.S3({
            useAccelerateEndpoint: true,
            s3BucketEndpoint: true,
            endpoint: 'foo.region.amazonaws.com'
          });
          req = build('getObject', {
            Bucket: 'foo',
            Key: 'baz'
          });
          return expect(req.endpoint.hostname).to.equal('foo.s3-accelerate.amazonaws.com');
        });
        return describe('does not use s3-accelerate.dualstack or s3-accelerate', function() {
          it('on dns-incompatible buckets', function() {
            var req;
            req = build('getObject', {
              Bucket: 'foo.baz',
              Key: 'bar'
            });
            return expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
          });
          return it('on excluded operations', function() {
            var req;
            req = build('listBuckets');
            expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
            req = build('createBucket', {
              Bucket: 'foo'
            });
            expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
            req = build('deleteBucket', {
              Bucket: 'foo'
            });
            return expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
          });
        });
      });
      describe('with useAccelerateEndpoint and dualstack set to true', function() {
        beforeEach(function() {
          return s3 = new AWS.S3({
            useAccelerateEndpoint: true,
            useDualstack: true
          });
        });
        it('changes the hostname to use s3-accelerate for dns-comaptible buckets', function() {
          var req;
          req = build('getObject', {
            Bucket: 'foo',
            Key: 'bar'
          });
          return expect(req.endpoint.hostname).to.equal('foo.s3-accelerate.dualstack.amazonaws.com');
        });
        it('overrides s3BucketEndpoint configuration when s3BucketEndpoint is set', function() {
          var req;
          s3 = new AWS.S3({
            useAccelerateEndpoint: true,
            useDualstack: true,
            s3BucketEndpoint: true,
            endpoint: 'foo.region.amazonaws.com'
          });
          req = build('getObject', {
            Bucket: 'foo',
            Key: 'baz'
          });
          return expect(req.endpoint.hostname).to.equal('foo.s3-accelerate.dualstack.amazonaws.com');
        });
        return describe('does not use s3-accelerate.dualstack or s3-accelerate', function() {
          it('on dns-incompatible buckets', function() {
            var req;
            req = build('getObject', {
              Bucket: 'foo.baz',
              Key: 'bar'
            });
            return expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
          });
          return it('on excluded operations', function() {
            var req;
            req = build('listBuckets');
            expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
            req = build('createBucket', {
              Bucket: 'foo'
            });
            expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
            req = build('deleteBucket', {
              Bucket: 'foo'
            });
            return expect(req.endpoint.hostname).to.not.contain('s3-accelerate');
          });
        });
      });
      describe('uri escaped params', function() {
        it('uri-escapes path and querystring params', function() {
          var params, req;
          params = {
            Bucket: 'bucket',
            Key: 'a b c',
            VersionId: 'a&b'
          };
          req = build('headObject', params);
          return expect(req.path).to.equal('/a%20b%20c?versionId=a%26b');
        });
        it('does not uri-escape forward slashes in the path', function() {
          var params, req;
          params = {
            Bucket: 'bucket',
            Key: 'k e/y'
          };
          req = build('headObject', params);
          return expect(req.path).to.equal('/k%20e/y');
        });
        return it('ensures a single forward slash exists', function() {
          var req;
          req = build('listObjects', {
            Bucket: 'bucket'
          });
          expect(req.path).to.equal('/');
          req = build('listObjects', {
            Bucket: 'bucket',
            MaxKeys: 123
          });
          return expect(req.path).to.equal('/?max-keys=123');
        });
      });
      describe('adding Expect: 100-continue', function() {
        if (AWS.util.isNode()) {
          it('does not add expect header to payloads less than 1MB', function() {
            var req;
            req = build('putObject', {
              Bucket: 'bucket',
              Key: 'key',
              Body: new Buffer(1024 * 1024 - 1)
            });
            return expect(req.headers['Expect']).not.to.exist;
          });
          it('adds expect header to payloads greater than 1MB', function() {
            var req;
            req = build('putObject', {
              Bucket: 'bucket',
              Key: 'key',
              Body: new Buffer(1024 * 1024 + 1)
            });
            return expect(req.headers['Expect']).to.equal('100-continue');
          });
        }
        if (AWS.util.isBrowser()) {
          beforeEach(function() {
            return helpers.spyOn(AWS.util, 'isBrowser').andReturn(true);
          });
          return it('does not add expect header in the browser', function() {
            var req;
            req = build('putObject', {
              Bucket: 'bucket',
              Key: 'key',
              Body: new Buffer(1024 * 1024 + 1)
            });
            return expect(req.headers['Expect']).not.to.exist;
          });
        }
      });
      describe('with s3DisableBodySigning set to true', function() {
        it('will disable body signing when using signature version 4 and the endpoint uses https', function() {
          var req;
          s3 = new AWS.S3({
            s3DisableBodySigning: true,
            signatureVersion: 'v4'
          });
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: new Buffer(1024 * 1024 * 5)
          });
          return expect(req.headers['X-Amz-Content-Sha256']).to.equal('UNSIGNED-PAYLOAD');
        });
        it('will compute contentMD5', function() {
          var buf, req;
          s3 = new AWS.S3({
            s3DisableBodySigning: true,
            signatureVersion: 'v4'
          });
          buf = new Buffer(1024 * 1024 * 5);
          buf.fill(0);
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: buf
          });
          return expect(req.headers['Content-MD5']).to.equal('XzY+DlipXwbL6bvGYsXftg==');
        });
        it('will not disable body signing when the endpoint is not https', function() {
          var req;
          s3 = new AWS.S3({
            s3DisableBodySigning: true,
            signatureVersion: 'v4',
            sslEnabled: false
          });
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: new Buffer(1024 * 1024 * 5)
          });
          expect(req.headers['X-Amz-Content-Sha256']).to.exist;
          return expect(req.headers['X-Amz-Content-Sha256']).to.not.equal('UNSIGNED-PAYLOAD');
        });
        return it('will have no effect when sigv2 signing is used', function() {
          var req;
          s3 = new AWS.S3({
            s3DisableBodySigning: true,
            signatureVersion: 's3',
            sslEnabled: true
          });
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: new Buffer(1024 * 1024 * 5)
          });
          return expect(req.headers['X-Amz-Content-Sha256']).to.not.exist;
        });
      });
      describe('with s3DisableBodySigning set to false', function() {
        it('will sign the body when sigv4 is used', function() {
          var req;
          s3 = new AWS.S3({
            s3DisableBodySigning: false,
            signatureVersion: 'v4'
          });
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: new Buffer(1024 * 1024 * 5)
          });
          expect(req.headers['X-Amz-Content-Sha256']).to.exist;
          return expect(req.headers['X-Amz-Cotnent-Sha256']).to.not.equal('UNSIGNED-PAYLOAD');
        });
        return it('will have no effect when sigv2 signing is used', function() {
          var req;
          s3 = new AWS.S3({
            s3DisableBodySigning: false,
            signatureVersion: 's3',
            sslEnabled: true
          });
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: new Buffer(1024 * 1024 * 5)
          });
          return expect(req.headers['X-Amz-Content-Sha256']).to.not.exist;
        });
      });
      describe('adding Content-Type', function() {
        beforeEach(function() {
          return helpers.spyOn(AWS.util, 'isBrowser').andReturn(true);
        });
        it('adds default content-type when not supplied', function() {
          var req;
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: 'body'
          });
          return expect(req.headers['Content-Type']).to.equal('application/octet-stream; charset=UTF-8');
        });
        it('does not add content-type for GET/HEAD requests', function() {
          var req;
          req = build('getObject', {
            Bucket: 'bucket',
            Key: 'key'
          });
          expect(req.headers['Content-Type']).not.to.exist;
          req = build('headObject', {
            Bucket: 'bucket',
            Key: 'key'
          });
          return expect(req.headers['Content-Type']).not.to.exist;
        });
        it('adds charset to existing content-type if not supplied', function() {
          var req;
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: 'body',
            ContentType: 'text/html'
          });
          return expect(req.headers['Content-Type']).to.equal('text/html; charset=UTF-8');
        });
        it('normalized charset to uppercase', function() {
          var req;
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: 'body',
            ContentType: 'text/html; charset=utf-8'
          });
          return expect(req.headers['Content-Type']).to.equal('text/html; charset=UTF-8');
        });
        return it('does not add charset to non-string data', function() {
          var req;
          req = build('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            Body: new Buffer('body'),
            ContentType: 'image/png'
          });
          return expect(req.headers['Content-Type']).to.equal('image/png');
        });
      });
      return describe('virtual-hosted vs path-style bucket requests', function() {
        describe('HTTPS', function() {
          beforeEach(function() {
            return s3 = new AWS.S3({
              sslEnabled: true,
              region: void 0
            });
          });
          it('puts dns-compat bucket names in the hostname', function() {
            var req;
            req = build('headObject', {
              Bucket: 'bucket-name',
              Key: 'abc'
            });
            expect(req.method).to.equal('HEAD');
            expect(req.endpoint.hostname).to.equal('bucket-name.s3.amazonaws.com');
            return expect(req.path).to.equal('/abc');
          });
          it('ensures the path contains / at a minimum when moving bucket', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket-name'
            });
            expect(req.endpoint.hostname).to.equal('bucket-name.s3.amazonaws.com');
            return expect(req.path).to.equal('/');
          });
          it('puts dns-compat bucket names in path if they contain a dot', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket.name'
            });
            expect(req.endpoint.hostname).to.equal('s3.amazonaws.com');
            return expect(req.path).to.equal('/bucket.name');
          });
          it('puts dns-compat bucket names in path if configured to do so', function() {
            var req;
            s3 = new AWS.S3({
              sslEnabled: true,
              s3ForcePathStyle: true,
              region: void 0
            });
            req = build('listObjects', {
              Bucket: 'bucket-name'
            });
            expect(req.endpoint.hostname).to.equal('s3.amazonaws.com');
            return expect(req.path).to.equal('/bucket-name');
          });
          return it('puts dns-incompat bucket names in path', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket_name'
            });
            expect(req.endpoint.hostname).to.equal('s3.amazonaws.com');
            return expect(req.path).to.equal('/bucket_name');
          });
        });
        describe('HTTP', function() {
          beforeEach(function() {
            return s3 = new AWS.S3({
              sslEnabled: false,
              region: void 0
            });
          });
          it('puts dns-compat bucket names in the hostname', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket-name'
            });
            expect(req.endpoint.hostname).to.equal('bucket-name.s3.amazonaws.com');
            return expect(req.path).to.equal('/');
          });
          it('puts dns-compat bucket names in the hostname if they contain a dot', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket.name'
            });
            expect(req.endpoint.hostname).to.equal('bucket.name.s3.amazonaws.com');
            return expect(req.path).to.equal('/');
          });
          return it('puts dns-incompat bucket names in path', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket_name'
            });
            expect(req.endpoint.hostname).to.equal('s3.amazonaws.com');
            return expect(req.path).to.equal('/bucket_name');
          });
        });
        describe('HTTPS dualstack', function() {
          beforeEach(function() {
            return s3 = new AWS.S3({
              sslEnabled: true,
              region: void 0,
              useDualstack: true
            });
          });
          it('puts dns-compat bucket names in the hostname', function() {
            var req;
            req = build('headObject', {
              Bucket: 'bucket-name',
              Key: 'abc'
            });
            expect(req.method).to.equal('HEAD');
            expect(req.endpoint.hostname).to.equal('bucket-name.s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/abc');
          });
          it('ensures the path contains / at a minimum when moving bucket', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket-name'
            });
            expect(req.endpoint.hostname).to.equal('bucket-name.s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/');
          });
          it('puts dns-compat bucket names in path if they contain a dot', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket.name'
            });
            expect(req.endpoint.hostname).to.equal('s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/bucket.name');
          });
          it('puts dns-compat bucket names in path if configured to do so', function() {
            var req;
            s3 = new AWS.S3({
              sslEnabled: true,
              s3ForcePathStyle: true,
              region: void 0,
              useDualstack: true
            });
            req = build('listObjects', {
              Bucket: 'bucket-name'
            });
            expect(req.endpoint.hostname).to.equal('s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/bucket-name');
          });
          return it('puts dns-incompat bucket names in path', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket_name'
            });
            expect(req.endpoint.hostname).to.equal('s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/bucket_name');
          });
        });
        return describe('HTTP dualstack', function() {
          beforeEach(function() {
            return s3 = new AWS.S3({
              sslEnabled: false,
              region: void 0,
              useDualstack: true
            });
          });
          it('puts dns-compat bucket names in the hostname', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket-name'
            });
            expect(req.endpoint.hostname).to.equal('bucket-name.s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/');
          });
          it('puts dns-compat bucket names in the hostname if they contain a dot', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket.name'
            });
            expect(req.endpoint.hostname).to.equal('bucket.name.s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/');
          });
          return it('puts dns-incompat bucket names in path', function() {
            var req;
            req = build('listObjects', {
              Bucket: 'bucket_name'
            });
            expect(req.endpoint.hostname).to.equal('s3.dualstack.us-east-1.amazonaws.com');
            return expect(req.path).to.equal('/bucket_name');
          });
        });
      });
    });
    describe('SSE support', function() {
      beforeEach(function() {
        return s3 = new AWS.S3;
      });
      it('fails if the scheme is not HTTPS: when SSECustomerKey is provided', function() {
        var req;
        req = s3.putObject({
          Bucket: 'bucket',
          Key: 'key',
          Body: 'object',
          SSECustomerKey: 'sse-key',
          SSECustomerAlgorithm: 'AES256'
        });
        req.httpRequest.endpoint.protocol = 'http:';
        req.build();
        return expect(req.response.error.code).to.equal('ConfigError');
      });
      it('fails if the scheme is not HTTPS: when CopySourceSSECustomerKey is provided', function() {
        var req;
        req = s3.putObject({
          Bucket: 'bucket',
          Key: 'key',
          Body: 'object',
          CopySourceSSECustomerKey: 'sse-key',
          CopySourceSSECustomerAlgorithm: 'AES256'
        });
        req.httpRequest.endpoint.protocol = 'http:';
        req.build();
        return expect(req.response.error.code).to.equal('ConfigError');
      });
      describe('SSECustomerKey', function() {
        it('encodes strings keys and fills in MD5', function() {
          var req;
          req = s3.putObject({
            Bucket: 'bucket',
            Key: 'key',
            Body: 'data',
            SSECustomerKey: 'KEY',
            SSECustomerAlgorithm: 'AES256'
          });
          req.build();
          expect(req.httpRequest.headers['x-amz-server-side-encryption-customer-key']).to.equal('S0VZ');
          return expect(req.httpRequest.headers['x-amz-server-side-encryption-customer-key-MD5']).to.equal('O1lJ4MJrh3Z6R1Kidt6VcA==');
        });
        return it('encodes blob keys and fills in MD5', function() {
          var req;
          req = s3.putObject({
            Bucket: 'bucket',
            Key: 'key',
            Body: 'data',
            SSECustomerKey: new AWS.util.Buffer('098f6bcd4621d373cade4e832627b4f6', 'hex'),
            SSECustomerAlgorithm: 'AES256'
          });
          req.build();
          expect(req.httpRequest.headers['x-amz-server-side-encryption-customer-key']).to.equal('CY9rzUYh03PK3k6DJie09g==');
          return expect(req.httpRequest.headers['x-amz-server-side-encryption-customer-key-MD5']).to.equal('YM1UqSjLvLtue1WVurRqng==');
        });
      });
      return describe('CopySourceSSECustomerKey', function() {
        it('encodes string keys and fills in MD5', function() {
          var req;
          req = s3.copyObject({
            Bucket: 'bucket',
            Key: 'key',
            CopySource: 'bucket/oldkey',
            Body: 'data',
            CopySourceSSECustomerKey: 'KEY',
            CopySourceSSECustomerAlgorithm: 'AES256'
          });
          req.build();
          expect(req.httpRequest.headers['x-amz-copy-source-server-side-encryption-customer-key']).to.equal('S0VZ');
          return expect(req.httpRequest.headers['x-amz-copy-source-server-side-encryption-customer-key-MD5']).to.equal('O1lJ4MJrh3Z6R1Kidt6VcA==');
        });
        return it('encodes blob keys and fills in MD5', function() {
          var req;
          req = s3.copyObject({
            Bucket: 'bucket',
            Key: 'key',
            CopySource: 'bucket/oldkey',
            Body: 'data',
            CopySourceSSECustomerKey: new AWS.util.Buffer('098f6bcd4621d373cade4e832627b4f6', 'hex'),
            CopySourceSSECustomerAlgorithm: 'AES256'
          });
          req.build();
          expect(req.httpRequest.headers['x-amz-copy-source-server-side-encryption-customer-key']).to.equal('CY9rzUYh03PK3k6DJie09g==');
          return expect(req.httpRequest.headers['x-amz-copy-source-server-side-encryption-customer-key-MD5']).to.equal('YM1UqSjLvLtue1WVurRqng==');
        });
      });
    });
    describe('retry behavior', function() {
      return it('retries RequestTimeout errors', function() {
        s3.config.maxRetries = 3;
        helpers.mockHttpResponse(400, {}, '<xml><Code>RequestTimeout</Code><Message>message</Message></xml>');
        return s3.putObject(function(err, data) {
          return expect(this.retryCount).to.equal(s3.config.maxRetries);
        });
      });
    });
    describe('upload', function() {
      it('accepts parameters in upload() call', function() {
        var done;
        helpers.mockResponses([
          {
            data: {
              ETag: 'ETAG'
            }
          }
        ]);
        done = false;
        s3.upload({
          Bucket: 'bucket',
          Key: 'key',
          Body: 'body'
        }, function() {
          return done = true;
        });
        return expect(done).to.equal(true);
      });
      it('accepts options as a second parameter', function() {
        var upload;
        helpers.mockResponses([
          {
            data: {
              ETag: 'ETAG'
            }
          }
        ]);
        upload = s3.upload({
          Bucket: 'bucket',
          Key: 'key',
          Body: 'body'
        }, {
          queueSize: 2
        }, function() {});
        return expect(upload.queueSize).to.equal(2);
      });
      return it('does not send if no callback is supplied', function() {
        return s3.upload({
          Bucket: 'bucket',
          Key: 'key',
          Body: 'body'
        });
      });
    });
    describe('extractData', function() {
      return it('caches bucket region if found in header', function() {
        var req, resp;
        req = request('operation', {
          Bucket: 'name'
        });
        resp = new AWS.Response(req);
        resp.httpResponse.headers = {
          'x-amz-bucket-region': 'rg-fake-1'
        };
        req.emit('extractData', [resp]);
        return expect(s3.bucketRegionCache.name).to.equal('rg-fake-1');
      });
    });
    describe('errors with no XML body', function() {
      var extractError, maxKeysParam, regionReqOperation;
      regionReqOperation = AWS.util.isNode() ? 'headBucket' : 'listObjects';
      maxKeysParam = regionReqOperation === 'listObjects' ? 0 : void 0;
      extractError = function(statusCode, body, addHeaders, req) {
        var header, resp, value;
        if (!req) {
          req = request('operation');
        }
        resp = new AWS.Response(req);
        resp.httpResponse.body = new Buffer(body || '');
        resp.httpResponse.statusCode = statusCode;
        resp.httpResponse.headers = {
          'x-amz-request-id': 'RequestId',
          'x-amz-id-2': 'ExtendedRequestId'
        };
        for (header in addHeaders) {
          value = addHeaders[header];
          resp.httpResponse.headers[header] = value;
        }
        req.emit('extractError', [resp]);
        return resp.error;
      };
      it('handles 304 errors', function() {
        var error;
        error = extractError(304);
        expect(error.code).to.equal('NotModified');
        return expect(error.message).to.equal(null);
      });
      it('handles 400 errors', function() {
        var error;
        error = extractError(400);
        expect(error.code).to.equal('BadRequest');
        return expect(error.message).to.equal(null);
      });
      it('handles 403 errors', function() {
        var error;
        error = extractError(403);
        expect(error.code).to.equal('Forbidden');
        return expect(error.message).to.equal(null);
      });
      it('handles 404 errors', function() {
        var error;
        error = extractError(404);
        expect(error.code).to.equal('NotFound');
        return expect(error.message).to.equal(null);
      });
      it('extracts the region from body and takes precedence over cache', function() {
        var body, error, req;
        s3.bucketRegionCache.name = 'us-west-2';
        req = request('operation', {
          Bucket: 'name'
        });
        body = "<Error>\n  <Code>InvalidArgument</Code>\n  <Message>Provided param is bad</Message>\n  <Region>eu-west-1</Region>\n</Error>";
        error = extractError(400, body, {}, req);
        expect(error.region).to.equal('eu-west-1');
        return expect(s3.bucketRegionCache.name).to.equal('eu-west-1');
      });
      it('extracts the region from header and takes precedence over body and cache', function() {
        var body, error, headers, req;
        s3.bucketRegionCache.name = 'us-west-2';
        req = request('operation', {
          Bucket: 'name'
        });
        body = "<Error>\n  <Code>InvalidArgument</Code>\n  <Message>Provided param is bad</Message>\n  <Region>eu-west-1</Region>\n</Error>";
        headers = {
          'x-amz-bucket-region': 'us-east-1'
        };
        error = extractError(400, body, headers, req);
        expect(error.region).to.equal('us-east-1');
        return expect(s3.bucketRegionCache.name).to.equal('us-east-1');
      });
      it('uses cache if region not extracted from body or header', function() {
        var body, error, req;
        s3.bucketRegionCache.name = 'us-west-2';
        req = request('operation', {
          Bucket: 'name'
        });
        body = "<Error>\n  <Code>InvalidArgument</Code>\n  <Message>Provided param is bad</Message>\n</Error>";
        error = extractError(400, body, {}, req);
        expect(error.region).to.equal('us-west-2');
        return expect(s3.bucketRegionCache.name).to.equal('us-west-2');
      });
      it('does not use cache if not different from current region', function() {
        var body, error, req;
        s3.bucketRegionCache.name = 'us-west-2';
        req = request('operation', {
          Bucket: 'name'
        });
        req.httpRequest.region = 'us-west-2';
        body = "<Error>\n  <Code>InvalidArgument</Code>\n  <Message>Provided param is bad</Message>\n</Error>";
        error = extractError(400, body);
        expect(error.region).to.not.exist;
        return expect(s3.bucketRegionCache.name).to.equal('us-west-2');
      });
      it('does not make async request for bucket region if error.region is set', function() {
        var body, error, headers, regionReq, req, spy;
        regionReq = {
          send: function(fn) {
            return fn();
          }
        };
        spy = helpers.spyOn(s3, regionReqOperation).andReturn(regionReq);
        req = request('operation', {
          Bucket: 'name'
        });
        body = "<Error>\n  <Code>PermanentRedirect</Code>\n  <Message>Message</Message>\n</Error>";
        headers = {
          'x-amz-bucket-region': 'us-east-1'
        };
        error = extractError(301, body, headers, req);
        expect(error.region).to.exist;
        expect(spy.calls.length).to.equal(0);
        return expect(regionReq._requestRegionForBucket).to.not.exist;
      });
      it('makes async request for bucket region if error.region not set for a region redirect error code', function() {
        var body, error, params, regionReq, req, spy;
        regionReq = {
          send: function(fn) {
            return fn();
          }
        };
        spy = helpers.spyOn(s3, regionReqOperation).andReturn(regionReq);
        params = {
          Bucket: 'name'
        };
        req = request('operation', params);
        body = "<Error>\n  <Code>PermanentRedirect</Code>\n  <Message>Message</Message>\n</Error>";
        error = extractError(301, body, {}, req);
        expect(error.region).to.not.exist;
        expect(spy.calls.length).to.equal(1);
        expect(spy.calls[0]["arguments"][0].Bucket).to.equal('name');
        expect(spy.calls[0]["arguments"][0].MaxKeys).to.equal(maxKeysParam);
        return expect(regionReq._requestRegionForBucket).to.exist;
      });
      it('does not make request for bucket region if error code is not a region redirect code', function() {
        var body, error, regionReq, req, spy;
        regionReq = {
          send: function(fn) {
            return fn();
          }
        };
        spy = helpers.spyOn(s3, regionReqOperation).andReturn(regionReq);
        req = request('operation', {
          Bucket: 'name'
        });
        body = "<Error>\n  <Code>InvalidCode</Code>\n  <Message>Message</Message>\n</Error>";
        error = extractError(301, body, {}, req);
        expect(error.region).to.not.exist;
        expect(spy.calls.length).to.equal(0);
        return expect(regionReq._requestRegionForBucket).to.not.exist;
      });
      it('updates error.region if async request adds region to cache', function() {
        var body, error, regionReq, req, spy;
        regionReq = {
          send: function(fn) {
            s3.bucketRegionCache.name = 'us-west-2';
            return fn();
          }
        };
        spy = helpers.spyOn(s3, regionReqOperation).andReturn(regionReq);
        req = request('operation', {
          Bucket: 'name'
        });
        body = "<Error>\n  <Code>PermanentRedirect</Code>\n  <Message>Message</Message>\n</Error>";
        error = extractError(301, body, {}, req);
        expect(spy.calls.length).to.equal(1);
        expect(spy.calls[0]["arguments"][0].Bucket).to.equal('name');
        expect(spy.calls[0]["arguments"][0].MaxKeys).to.equal(maxKeysParam);
        return expect(error.region).to.equal('us-west-2');
      });
      it('extracts the request ids', function() {
        var error;
        error = extractError(400);
        expect(error.requestId).to.equal('RequestId');
        return expect(error.extendedRequestId).to.equal('ExtendedRequestId');
      });
      it('misc errors not known to return an empty body', function() {
        var error;
        error = extractError(412);
        expect(error.code).to.equal(412);
        return expect(error.message).to.equal(null);
      });
      return it('uses canned errors only when the body is empty', function() {
        var body, error;
        body = "<xml>\n  <Code>ErrorCode</Code>\n  <Message>ErrorMessage</Message>\n</xml>";
        error = extractError(403, body);
        expect(error.code).to.equal('ErrorCode');
        return expect(error.message).to.equal('ErrorMessage');
      });
    });
    describe('retryableError', function() {
      it('should retry on authorization header with updated region', function() {
        var err, req, retryable;
        err = {
          code: 'AuthorizationHeaderMalformed',
          statusCode: 400,
          region: 'eu-west-1'
        };
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3.amazonaws.com');
      });
      it('should retry on bad request with updated region', function() {
        var err, req, retryable;
        err = {
          code: 'BadRequest',
          statusCode: 400,
          region: 'eu-west-1'
        };
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3.amazonaws.com');
      });
      it('should retry on permanent redirect with updated region and endpoint', function() {
        var err, req, retryable;
        err = {
          code: 'PermanentRedirect',
          statusCode: 301,
          region: 'eu-west-1'
        };
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3-eu-west-1.amazonaws.com');
      });
      it('should retry on error code 301 with updated region and endpoint', function() {
        var err, req, retryable;
        err = {
          code: 301,
          statusCode: 301,
          region: 'eu-west-1'
        };
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3-eu-west-1.amazonaws.com');
      });
      it('should retry with updated region but not endpoint if non-S3 url endpoint is specified', function() {
        var err, req, retryable;
        err = {
          code: 'PermanentRedirect',
          statusCode: 301,
          region: 'eu-west-1'
        };
        s3 = new AWS.S3({
          endpoint: 'https://fake-custom-url.com',
          s3BucketEndpoint: true
        });
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('fake-custom-url.com');
      });
      it('should retry with updated endpoint if S3 url endpoint is specified', function() {
        var err, req, retryable;
        err = {
          code: 'PermanentRedirect',
          statusCode: 301,
          region: 'eu-west-1'
        };
        s3 = new AWS.S3({
          endpoint: 'https://name.s3-us-west-2.amazonaws.com',
          s3BucketEndpoint: true
        });
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3-eu-west-1.amazonaws.com');
      });
      it('should retry with updated region but not endpoint if accelerate endpoint is used', function() {
        var err, req, retryable;
        err = {
          code: 'PermanentRedirect',
          statusCode: 301,
          region: 'eu-west-1'
        };
        s3 = new AWS.S3({
          useAccelerateEndpoint: true
        });
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3-accelerate.amazonaws.com');
      });
      it('should retry with updated endpoint if dualstack endpoint is used', function() {
        var err, req, retryable;
        err = {
          code: 'PermanentRedirect',
          statusCode: 301,
          region: 'eu-west-1'
        };
        s3 = new AWS.S3({
          useDualstack: true
        });
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        retryable = s3.retryableError(err, req);
        expect(retryable).to.equal(true);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3.dualstack.eu-west-1.amazonaws.com');
      });
      return it('should not retry on requests for bucket region once region is obtained', function() {
        var err, req, retryable;
        err = {
          code: 'PermanentRedirect',
          statusCode: 301,
          region: 'eu-west-1'
        };
        req = request('operation', {
          Bucket: 'name'
        });
        req._requestRegionForBucket = 'name';
        retryable = [];
        retryable.push(s3.retryableError(err, req));
        s3.bucketRegionCache.name = 'eu-west-1';
        retryable.push(s3.retryableError(err, req));
        return expect(retryable).to.eql([true, false]);
      });
    });
    describe('browser NetworkingError due to wrong region', function() {
      var callNetworkingErrorListener, done, regionReq, spy;
      done = function() {};
      spy = null;
      regionReq = null;
      callNetworkingErrorListener = function(req) {
        var resp;
        if (!req) {
          req = request('operation', {
            Bucket: 'name'
          });
        }
        if (req._asm.currentState === 'validate') {
          req.build();
        }
        resp = new AWS.Response(req);
        resp.error = {
          code: 'NetworkingError'
        };
        s3.reqRegionForNetworkingError(resp, done);
        return req;
      };
      beforeEach(function() {
        s3 = new AWS.S3({
          region: 'us-west-2'
        });
        regionReq = request('operation', {
          Bucket: 'name'
        });
        regionReq.send = function(fn) {
          return fn();
        };
        helpers.spyOn(AWS.util, 'isBrowser').andReturn(true);
        return spy = helpers.spyOn(s3, 'listObjects').andReturn(regionReq);
      });
      it('updates region to us-east-1 if bucket name not DNS compatible', function() {
        var req;
        req = request('operation', {
          Bucket: 'name!'
        });
        callNetworkingErrorListener(req);
        expect(req.httpRequest.region).to.equal('us-east-1');
        expect(req.httpRequest.endpoint.hostname).to.equal('s3.amazonaws.com');
        expect(s3.bucketRegionCache['name!']).to.equal('us-east-1');
        return expect(spy.calls.length).to.equal(0);
      });
      it('updates region if cached and not current region', function() {
        var req;
        req = request('operation', {
          Bucket: 'name'
        });
        req.build();
        s3.bucketRegionCache.name = 'eu-west-1';
        callNetworkingErrorListener(req);
        expect(req.httpRequest.region).to.equal('eu-west-1');
        expect(req.httpRequest.endpoint.hostname).to.equal('name.s3-eu-west-1.amazonaws.com');
        return expect(spy.calls.length).to.equal(0);
      });
      it('makes async request in us-east-1 if not in cache', function() {
        var req;
        regionReq.send = function(fn) {
          s3.bucketRegionCache.name = 'eu-west-1';
          return fn();
        };
        req = callNetworkingErrorListener();
        expect(spy.calls.length).to.equal(1);
        expect(regionReq.httpRequest.region).to.equal('us-east-1');
        expect(regionReq.httpRequest.endpoint.hostname).to.equal('name.s3.amazonaws.com');
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3-eu-west-1.amazonaws.com');
      });
      it('makes async request in us-east-1 if cached region matches current region', function() {
        var req;
        s3.bucketRegionCache.name = 'us-west-2';
        regionReq.send = function(fn) {
          s3.bucketRegionCache.name = 'eu-west-1';
          return fn();
        };
        req = callNetworkingErrorListener();
        expect(spy.calls.length).to.equal(1);
        expect(regionReq.httpRequest.region).to.equal('us-east-1');
        expect(regionReq.httpRequest.endpoint.hostname).to.equal('name.s3.amazonaws.com');
        expect(req.httpRequest.region).to.equal('eu-west-1');
        return expect(req.httpRequest.endpoint.hostname).to.equal('name.s3-eu-west-1.amazonaws.com');
      });
      return it('does not update region if path-style bucket is dns-compliant and not in cache', function() {
        var req;
        s3.config.s3ForcePathStyle = true;
        regionReq.send = function(fn) {
          s3.bucketRegionCache.name = 'eu-west-1';
          return fn();
        };
        req = callNetworkingErrorListener();
        expect(spy.calls.length).to.equal(0);
        expect(req.httpRequest.region).to.equal('us-west-2');
        return expect(req.httpRequest.endpoint.hostname).to.equal('s3-us-west-2.amazonaws.com');
      });
    });
    describe('getBucketAcl', function() {
      return it('correctly parses the ACL XML document', function() {
        var body, headers;
        headers = {
          'x-amz-request-id': 'request-id'
        };
        body = "<AccessControlPolicy xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  <AccessControlList>\n    <Grant>\n      <Grantee xsi:type=\"CanonicalUser\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n        <DisplayName>aws-sdk</DisplayName>\n        <ID>id</ID>\n      </Grantee>\n      <Permission>FULL_CONTROL</Permission>\n    </Grant>\n    <Grant>\n      <Grantee xsi:type=\"Group\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n        <URI>uri</URI>\n      </Grantee>\n      <Permission>READ</Permission>\n    </Grant>\n  </AccessControlList>\n  <Owner>\n    <DisplayName>aws-sdk</DisplayName>\n    <ID>id</ID>\n  </Owner>\n</AccessControlPolicy>";
        helpers.mockHttpResponse(200, headers, body);
        return s3.getBucketAcl(function(error, data) {
          expect(error).to.equal(null);
          return expect(data).to.eql({
            Owner: {
              DisplayName: 'aws-sdk',
              ID: 'id'
            },
            Grants: [
              {
                Permission: 'FULL_CONTROL',
                Grantee: {
                  Type: 'CanonicalUser',
                  DisplayName: 'aws-sdk',
                  ID: 'id'
                }
              }, {
                Permission: 'READ',
                Grantee: {
                  Type: 'Group',
                  URI: 'uri'
                }
              }
            ]
          });
        });
      });
    });
    describe('putBucketAcl', function() {
      return it('correctly builds the ACL XML document', function() {
        var params, xml;
        xml = "<AccessControlPolicy xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  <AccessControlList>\n    <Grant>\n      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"CanonicalUser\">\n        <DisplayName>aws-sdk</DisplayName>\n        <ID>id</ID>\n      </Grantee>\n      <Permission>FULL_CONTROL</Permission>\n    </Grant>\n    <Grant>\n      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"Group\">\n        <URI>uri</URI>\n      </Grantee>\n      <Permission>READ</Permission>\n    </Grant>\n  </AccessControlList>\n  <Owner>\n    <DisplayName>aws-sdk</DisplayName>\n    <ID>id</ID>\n  </Owner>\n</AccessControlPolicy>";
        helpers.mockHttpResponse(200, {}, '');
        params = {
          AccessControlPolicy: {
            Owner: {
              DisplayName: 'aws-sdk',
              ID: 'id'
            },
            Grants: [
              {
                Permission: 'FULL_CONTROL',
                Grantee: {
                  Type: 'CanonicalUser',
                  DisplayName: 'aws-sdk',
                  ID: 'id'
                }
              }, {
                Permission: 'READ',
                Grantee: {
                  Type: 'Group',
                  URI: 'uri'
                }
              }
            ]
          }
        };
        return s3.putBucketAcl(params, function(err, data) {
          return helpers.matchXML(this.request.httpRequest.body, xml);
        });
      });
    });
    describe('completeMultipartUpload', function() {
      it('returns data when the resp is 200 with valid response', function() {
        var body, headers;
        headers = {
          'x-amz-id-2': 'Uuag1LuByRx9e6j5Onimru9pO4ZVKnJ2Qz7/C1NPcfTWAtRPfTaOFg==',
          'x-amz-request-id': '656c76696e6727732072657175657374'
        };
        body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CompleteMultipartUploadResult xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  <Location>http://Example-Bucket.s3.amazonaws.com/Example-Object</Location>\n  <Bucket>Example-Bucket</Bucket>\n  <Key>Example-Object</Key>\n  <ETag>\"3858f62230ac3c915f300c664312c11f-9\"</ETag>\n</CompleteMultipartUploadResult>";
        helpers.mockHttpResponse(200, headers, body);
        return s3.completeMultipartUpload(function(error, data) {
          expect(error).to.equal(null);
          expect(data).to.eql({
            Location: 'http://Example-Bucket.s3.amazonaws.com/Example-Object',
            Bucket: 'Example-Bucket',
            Key: 'Example-Object',
            ETag: '"3858f62230ac3c915f300c664312c11f-9"'
          });
          return expect(this.requestId).to.equal('656c76696e6727732072657175657374');
        });
      });
      return it('returns an error when the resp is 200 with an error xml document', function() {
        var body;
        body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Error>\n  <Code>InternalError</Code>\n  <Message>We encountered an internal error. Please try again.</Message>\n  <RequestId>656c76696e6727732072657175657374</RequestId>\n  <HostId>Uuag1LuByRx9e6j5Onimru9pO4ZVKnJ2Qz7/C1NPcfTWAtRPfTaOFg==</HostId>\n</Error>";
        helpers.mockHttpResponse(200, {}, body);
        return s3.completeMultipartUpload(function(error, data) {
          expect(error).to.be.instanceOf(Error);
          expect(error.code).to.equal('InternalError');
          expect(error.message).to.equal('We encountered an internal error. Please try again.');
          expect(error.statusCode).to.equal(200);
          expect(error.retryable).to.equal(true);
          return expect(data).to.equal(null);
        });
      });
    });
    describe('copyObject', function() {
      it('returns data when the resp is 200 with valid response', function() {
        var body, headers;
        headers = {
          'x-amz-id-2': 'Uuag1LuByRx9e6j5Onimru9pO4ZVKnJ2Qz7/C1NPcfTWAtRPfTaOFg==',
          'x-amz-request-id': '656c76696e6727732072657175657374'
        };
        body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CopyObjectResult xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  <Location>http://Example-Bucket.s3.amazonaws.com/Example-Object</Location>\n  <Bucket>Example-Bucket</Bucket>\n  <Key>Example-Object</Key>\n  <ETag>\"3858f62230ac3c915f300c664312c11f-9\"</ETag>\n</CopyObjectResult>";
        helpers.mockHttpResponse(200, headers, body);
        return s3.copyObject(function(error, data) {
          expect(error).to.equal(null);
          expect(data).to.eql({
            CopyObjectResult: {
              ETag: '"3858f62230ac3c915f300c664312c11f-9"'
            }
          });
          return expect(this.requestId).to.equal('656c76696e6727732072657175657374');
        });
      });
      return it('returns an error when the resp is 200 with an error xml document', function() {
        var body;
        body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Error>\n  <Code>InternalError</Code>\n  <Message>We encountered an internal error. Please try again.</Message>\n  <RequestId>656c76696e6727732072657175657374</RequestId>\n  <HostId>Uuag1LuByRx9e6j5Onimru9pO4ZVKnJ2Qz7/C1NPcfTWAtRPfTaOFg==</HostId>\n</Error>";
        helpers.mockHttpResponse(200, {}, body);
        return s3.copyObject(function(error, data) {
          expect(error).to.be.instanceOf(Error);
          expect(error.code).to.equal('InternalError');
          expect(error.message).to.equal('We encountered an internal error. Please try again.');
          expect(error.statusCode).to.equal(200);
          expect(error.retryable).to.equal(true);
          return expect(data).to.equal(null);
        });
      });
    });
    describe('uploadPartCopy', function() {
      it('returns data when the resp is 200 with valid response', function() {
        var body, headers;
        headers = {
          'x-amz-id-2': 'Uuag1LuByRx9e6j5Onimru9pO4ZVKnJ2Qz7/C1NPcfTWAtRPfTaOFg==',
          'x-amz-request-id': '656c76696e6727732072657175657374'
        };
        body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CopyPartResult xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  <Location>http://Example-Bucket.s3.amazonaws.com/Example-Object</Location>\n  <Bucket>Example-Bucket</Bucket>\n  <Key>Example-Object</Key>\n  <ETag>\"3858f62230ac3c915f300c664312c11f-9\"</ETag>\n</CopyPartResult>";
        helpers.mockHttpResponse(200, headers, body);
        return s3.uploadPartCopy({
          Bucket: 'bucket',
          Key: 'key',
          CopySource: 'bucket/key'
        }, function(error, data) {
          expect(error).to.equal(null);
          expect(data).to.eql({
            CopyPartResult: {
              ETag: '"3858f62230ac3c915f300c664312c11f-9"'
            }
          });
          return expect(this.requestId).to.equal('656c76696e6727732072657175657374');
        });
      });
      return it('returns an error when the resp is 200 with an error xml document', function() {
        var body;
        body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Error>\n  <Code>InternalError</Code>\n  <Message>We encountered an internal error. Please try again.</Message>\n  <RequestId>656c76696e6727732072657175657374</RequestId>\n  <HostId>Uuag1LuByRx9e6j5Onimru9pO4ZVKnJ2Qz7/C1NPcfTWAtRPfTaOFg==</HostId>\n</Error>";
        helpers.mockHttpResponse(200, {}, body);
        return s3.uploadPartCopy(function(error, data) {
          expect(error).to.be.instanceOf(Error);
          expect(error.code).to.equal('InternalError');
          expect(error.message).to.equal('We encountered an internal error. Please try again.');
          expect(error.statusCode).to.equal(200);
          expect(error.retryable).to.equal(true);
          return expect(data).to.equal(null);
        });
      });
    });
    describe('getBucketLocation', function() {
      it('returns empty string for the location constraint when not present', function() {
        var body;
        body = '<?xml version="1.0" encoding="UTF-8"?>\n<LocationConstraint xmlns="http://s3.amazonaws.com/doc/2006-03-01/"/>';
        helpers.mockHttpResponse(200, {}, body);
        return s3.getBucketLocation(function(error, data) {
          expect(error).to.equal(null);
          return expect(data).to.eql({
            LocationConstraint: ''
          });
        });
      });
      return it('parses the location constraint from the root xml', function() {
        var body, headers;
        headers = {
          'x-amz-request-id': 'abcxyz'
        };
        body = '<?xml version="1.0" encoding="UTF-8"?>\n<LocationConstraint xmlns="http://s3.amazonaws.com/doc/2006-03-01/">EU</LocationConstraint>';
        helpers.mockHttpResponse(200, headers, body);
        return s3.getBucketLocation(function(error, data) {
          expect(error).to.equal(null);
          expect(data).to.eql({
            LocationConstraint: 'EU'
          });
          return expect(this.requestId).to.equal('abcxyz');
        });
      });
    });
    describe('createBucket', function() {
      it('auto-populates the LocationConstraint based on the region', function() {
        var loc;
        loc = null;
        s3 = new AWS.S3({
          region: 'eu-west-1'
        });
        s3.makeRequest = function(op, params) {
          expect(params).to['be'].a('object');
          return loc = params.CreateBucketConfiguration.LocationConstraint;
        };
        s3.createBucket({
          Bucket: 'name'
        });
        return expect(loc).to.equal('eu-west-1');
      });
      it('auto-populates the LocationConstraint based on the region when using bound params', function() {
        var loc;
        loc = null;
        s3 = new AWS.S3({
          region: 'eu-west-1',
          Bucket: 'name'
        });
        s3.makeRequest = function(op, params) {
          expect(params).to['be'].a('object');
          return loc = params.CreateBucketConfiguration.LocationConstraint;
        };
        s3.createBucket(AWS.util.fn.noop);
        return expect(loc).to.equal('eu-west-1');
      });
      it('auto-populates the LocationConstraint based on the region when using invalid params', function() {
        var loc;
        loc = null;
        s3 = new AWS.S3({
          region: 'eu-west-1',
          Bucket: 'name'
        });
        s3.makeRequest = function(op, params) {
          expect(params).to['be'].a('object');
          return loc = params.CreateBucketConfiguration.LocationConstraint;
        };
        s3.createBucket(null);
        expect(loc).to.equal('eu-west-1');
        s3.createBucket(void 0);
        return expect(loc).to.equal('eu-west-1');
      });
      it('auto-populates the LocationConstraint based on the region when using invalid params and a valid callback', function() {
        var called, loc;
        loc = null;
        s3 = new AWS.S3({
          region: 'eu-west-1',
          Bucket: 'name'
        });
        s3.makeRequest = function(op, params, cb) {
          expect(params).to['be'].a('object');
          loc = params.CreateBucketConfiguration.LocationConstraint;
          if (typeof cb === 'function') {
            return cb();
          }
        };
        called = 0;
        s3.createBucket(void 0, function() {
          return called = 1;
        });
        expect(loc).to.equal('eu-west-1');
        return expect(called).to.equal(1);
      });
      it('caches bucket region based on LocationConstraint upon successful response', function() {
        var params;
        s3 = new AWS.S3();
        params = {
          Bucket: 'name',
          CreateBucketConfiguration: {
            LocationConstraint: 'rg-fake-1'
          }
        };
        helpers.mockHttpResponse(200, {}, '');
        return s3.createBucket(params, function() {
          return expect(s3.bucketRegionCache.name).to.equal('rg-fake-1');
        });
      });
      it('caches bucket region without LocationConstraint upon successful response', function() {
        var params;
        s3 = new AWS.S3({
          region: 'us-east-1'
        });
        params = {
          Bucket: 'name'
        };
        helpers.mockHttpResponse(200, {}, '');
        return s3.createBucket(params, function() {
          expect(params.CreateBucketConfiguration).to.not.exist;
          return expect(s3.bucketRegionCache.name).to.equal('us-east-1');
        });
      });
      return it('caches bucket region with LocationConstraint "EU" upon successful response', function() {
        var params;
        s3 = new AWS.S3();
        params = {
          Bucket: 'name',
          CreateBucketConfiguration: {
            LocationConstraint: 'EU'
          }
        };
        helpers.mockHttpResponse(200, {}, '');
        return s3.createBucket(params, function() {
          return expect(s3.bucketRegionCache.name).to.equal('eu-west-1');
        });
      });
    });
    describe('deleteBucket', function() {
      return it('removes bucket from region cache on successful response', function() {
        var params;
        s3 = new AWS.S3();
        params = {
          Bucket: 'name'
        };
        s3.bucketRegionCache.name = 'rg-fake-1';
        helpers.mockHttpResponse(204, {}, '');
        return s3.deleteBucket(params, function() {
          return expect(s3.bucketRegionCache.name).to.not.exist;
        });
      });
    });
    AWS.util.each(AWS.S3.prototype.computableChecksumOperations, function(operation) {
      return describe(operation, function() {
        return it('forces Content-MD5 header parameter', function() {
          var hash, req;
          req = s3[operation]({
            Bucket: 'bucket',
            ContentMD5: '000'
          }).build();
          hash = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
          return expect(req.httpRequest.headers['Content-MD5']).to.equal(hash);
        });
      });
    });
    describe('willComputeChecksums', function() {
      var willCompute;
      willCompute = function(operation, opts) {
        var checksum, compute, realChecksum, req;
        compute = opts.computeChecksums;
        s3 = new AWS.S3({
          computeChecksums: compute,
          signatureVersion: 's3'
        });
        req = s3.makeRequest(operation, {
          Bucket: 'example',
          ContentMD5: opts.hash
        }).build();
        checksum = req.httpRequest.headers['Content-MD5'];
        if (opts.hash !== void 0) {
          if (opts.hash === null) {
            return expect(checksum).not.to.exist;
          } else {
            return expect(checksum).to.equal(opts.hash);
          }
        } else {
          realChecksum = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
          return expect(checksum).to.equal(realChecksum);
        }
      };
      it('computes checksums if the operation requires it', function() {
        willCompute('deleteObjects', {
          computeChecksums: true
        });
        willCompute('putBucketCors', {
          computeChecksums: true
        });
        willCompute('putBucketLifecycle', {
          computeChecksums: true
        });
        willCompute('putBucketLifecycleConfiguration', {
          computeChecksums: true
        });
        willCompute('putBucketTagging', {
          computeChecksums: true
        });
        return willCompute('putBucketReplication', {
          computeChecksums: true
        });
      });
      it('computes checksums if computeChecksums is off and operation requires it', function() {
        willCompute('deleteObjects', {
          computeChecksums: false
        });
        willCompute('putBucketCors', {
          computeChecksums: false
        });
        willCompute('putBucketLifecycle', {
          computeChecksums: false
        });
        willCompute('putBucketLifecycleConfiguration', {
          computeChecksums: false
        });
        willCompute('putBucketTagging', {
          computeChecksums: false
        });
        return willCompute('putBucketReplication', {
          computeChecksums: false
        });
      });
      it('does not compute checksums if computeChecksums is off', function() {
        return willCompute('putObject', {
          computeChecksums: false,
          hash: null
        });
      });
      it('does not compute checksums if computeChecksums is on and ContentMD5 is provided', function() {
        return willCompute('putBucketAcl', {
          computeChecksums: true,
          hash: '000'
        });
      });
      it('computes checksums if computeChecksums is on and ContentMD5 is not provided', function() {
        return willCompute('putBucketAcl', {
          computeChecksums: true
        });
      });
      if (AWS.util.isNode()) {
        it('does not compute checksums for Stream objects', function() {
          var req;
          s3 = new AWS.S3({
            computeChecksums: true
          });
          req = s3.putObject({
            Bucket: 'example',
            Key: 'foo',
            Body: new Stream.Stream
          });
          return expect(req.build(function() {}).httpRequest.headers['Content-MD5']).to.equal(void 0);
        });
        it('throws an error in SigV4, if a non-file stream is provided when body signing enabled', function(done) {
          var req;
          s3 = new AWS.S3({
            signatureVersion: 'v4',
            s3DisableBodySigning: false
          });
          req = s3.putObject({
            Bucket: 'example',
            Key: 'key',
            Body: new Stream.Stream
          });
          return req.send(function(err) {
            expect(err.message).to.contain('stream objects are not supported');
            return done();
          });
        });
        it('does not throw an error in SigV4, if a non-file stream is provided when body signing disabled with ContentLength', function(done) {
          var req;
          s3 = new AWS.S3({
            signatureVersion: 'v4',
            s3DisableBodySigning: true
          });
          helpers.mockResponse({
            data: {
              ETag: 'etag'
            }
          });
          req = s3.putObject({
            Bucket: 'example',
            Key: 'key',
            Body: new Stream.Stream,
            ContentLength: 10
          });
          return req.send(function(err) {
            expect(err).not.to.exist;
            return done();
          });
        });
        it('opens separate stream if a file object is provided (signed payload)', function(done) {
          var fs, hash, mock, req, stream;
          hash = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
          helpers.mockResponse({
            data: {
              ETag: 'etag'
            }
          });
          fs = require('fs');
          mock = helpers.spyOn(fs, 'createReadStream').andCallFake(function() {
            var tr;
            tr = new Stream.Transform;
            tr._transform = function(d, e, c) {
              return c(null, d);
            };
            tr.length = 0;
            tr.path = 'path/to/file';
            tr.push(new Buffer(''));
            tr.end();
            return tr;
          });
          s3 = new AWS.S3({
            signatureVersion: 'v4',
            s3DisableBodySigning: false
          });
          stream = fs.createReadStream('path/to/file');
          req = s3.putObject({
            Bucket: 'example',
            Key: 'key',
            Body: stream
          });
          return req.send(function(err) {
            expect(mock.calls[0]["arguments"]).to.eql(['path/to/file']);
            expect(mock.calls[1]["arguments"]).to.eql(['path/to/file', {}]);
            expect(err).not.to.exist;
            expect(req.httpRequest.headers['X-Amz-Content-Sha256']).to.equal(hash);
            return done();
          });
        });
        return it('opens separate stream with range if a file object is provided', function(done) {
          var fs, hash, mock, req, stream;
          hash = '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08';
          helpers.mockResponse({
            data: {
              ETag: 'etag'
            }
          });
          fs = require('fs');
          mock = helpers.spyOn(fs, 'createReadStream').andCallFake(function(path, settings) {
            var didRead, tr;
            tr = new Stream.Readable;
            tr.length = 0;
            tr.path = 'path/to/file';
            tr.start = settings.start;
            tr.end = settings.end;
            didRead = false;
            tr._read = function(n) {
              if (didRead) {
                return tr.push(null);
              } else {
                didRead = true;
                return tr.push(new Buffer('test'));
              }
            };
            return tr;
          });
          s3 = new AWS.S3({
            signatureVersion: 'v4',
            s3DisableBodySigning: false
          });
          stream = fs.createReadStream('path/to/file', {
            start: 0,
            end: 5
          });
          req = s3.putObject({
            Bucket: 'example',
            Key: 'key',
            Body: stream
          });
          return req.send(function(err) {
            expect(mock.calls[0]["arguments"]).to.eql([
              'path/to/file', {
                start: 0,
                end: 5
              }
            ]);
            expect(mock.calls[1]["arguments"]).to.eql([
              'path/to/file', {
                start: 0,
                end: 5
              }
            ]);
            expect(err).not.to.exist;
            expect(req.httpRequest.headers['X-Amz-Content-Sha256']).to.equal(hash);
            return done();
          });
        });
      }
    });
    describe('getSignedUrl', function() {
      var date;
      date = null;
      beforeEach(function(done) {
        date = AWS.util.date.getDate;
        AWS.util.date.getDate = function() {
          return new Date(0);
        };
        return done();
      });
      afterEach(function(done) {
        AWS.util.date.getDate = date;
        return done();
      });
      it('gets a signed URL for getObject', function() {
        var url;
        url = s3.getSignedUrl('getObject', {
          Bucket: 'bucket',
          Key: 'key'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/key?AWSAccessKeyId=akid&Expires=900&Signature=4mlYnRmz%2BBFEPrgYz5tXcl9Wc4w%3D&x-amz-security-token=session');
      });
      it('gets a signed URL with Expires time', function() {
        var url;
        url = s3.getSignedUrl('getObject', {
          Bucket: 'bucket',
          Key: 'key',
          Expires: 60
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/key?AWSAccessKeyId=akid&Expires=60&Signature=kH2pMK%2Fgm7cCZKVG8GHVTRGXKzY%3D&x-amz-security-token=session');
      });
      it('gets a signed URL with expiration and bound bucket parameters', function() {
        var url;
        s3 = new AWS.S3({
          paramValidation: true,
          region: void 0,
          params: {
            Bucket: 'bucket'
          }
        });
        url = s3.getSignedUrl('getObject', {
          Key: 'key',
          Expires: 60
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/key?AWSAccessKeyId=akid&Expires=60&Signature=kH2pMK%2Fgm7cCZKVG8GHVTRGXKzY%3D&x-amz-security-token=session');
      });
      it('generates the right URL with a custom endpoint', function() {
        var url;
        s3 = new AWS.S3({
          endpoint: 'https://foo.bar.baz:555/prefix',
          params: {
            Bucket: 'bucket'
          }
        });
        url = s3.getSignedUrl('getObject', {
          Key: 'key',
          Expires: 60
        });
        return expect(url).to.equal('https://bucket.foo.bar.baz:555/prefix/key?AWSAccessKeyId=akid&Expires=60&Signature=zA6k0cQqDkTZgLamfoYLOd%2Bqfg8%3D&x-amz-security-token=session');
      });
      it('gets a signed URL with callback', function(done) {
        return s3.getSignedUrl('getObject', {
          Bucket: 'bucket',
          Key: 'key'
        }, function(err, url) {
          expect(url).to.equal('https://bucket.s3.amazonaws.com/key?AWSAccessKeyId=akid&Expires=900&Signature=4mlYnRmz%2BBFEPrgYz5tXcl9Wc4w%3D&x-amz-security-token=session');
          return done();
        });
      });
      it('gets a signed URL for putObject with no body', function() {
        var url;
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'key'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/key?AWSAccessKeyId=akid&Expires=900&Signature=J%2BnWZ0lPUfLV0kio8ONhJmAttGc%3D&x-amz-security-token=session');
      });
      it('gets a signed URL for putObject with Metadata', function() {
        var url;
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'key',
          Metadata: {
            someKey: 'someValue'
          }
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/key?AWSAccessKeyId=akid&Expires=900&Signature=5Lcbv0WLGWseQhtmNQ8WwIpX6Kw%3D&x-amz-meta-somekey=someValue&x-amz-security-token=session');
      });
      it('gets a signed URL for putObject with Metadata using Sigv4', function() {
        var url;
        s3 = new AWS.S3({
          signatureVersion: 'v4'
        });
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'key',
          Metadata: {
            someKey: 'someValue'
          }
        });
        return expect(url).to.equal('https://bucket.s3.mock-region.amazonaws.com/key?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=akid%2F19700101%2Fmock-region%2Fs3%2Faws4_request&X-Amz-Date=19700101T000000Z&X-Amz-Expires=900&X-Amz-Security-Token=session&X-Amz-Signature=0a1ef336042a7a03b8a2e130ac36097cb1fbab54f8ed5105977a863a5139e679&X-Amz-SignedHeaders=host%3Bx-amz-meta-somekey&x-amz-meta-somekey=someValue');
      });
      it('gets a signed URL for putObject with special characters', function() {
        var url;
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: '!@#$%^&*();\':"{}[],./?`~'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/%21%40%23%24%25%5E%26%2A%28%29%3B%27%3A%22%7B%7D%5B%5D%2C./%3F%60~?AWSAccessKeyId=akid&Expires=900&Signature=9nEltJACZKsriZqU2cmRel6g8LQ%3D&x-amz-security-token=session');
      });
      it('gets a signed URL for putObject with a body (and checksum)', function() {
        var url;
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'key',
          Body: 'body'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/key?AWSAccessKeyId=akid&Content-MD5=hBotaJrYa9FhFEdFPCLG%2FA%3D%3D&Expires=900&Signature=4ycA2tpHKxfFnNCdqnK1d5BG8gc%3D&x-amz-security-token=session');
      });
      it('gets a signed URL for putObject with a sse-c algorithm', function() {
        var url;
        s3 = new AWS.S3({
          signatureVersion: 'v4'
        });
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'key',
          SSECustomerAlgorithm: 'AES256'
        });
        return expect(url).to.equal('https://bucket.s3.mock-region.amazonaws.com/key?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=akid%2F19700101%2Fmock-region%2Fs3%2Faws4_request&X-Amz-Date=19700101T000000Z&X-Amz-Expires=900&X-Amz-Security-Token=session&X-Amz-Signature=60b08f91f820fa1c698ac477fec7b5e3cec7b682e09e769e1a55a4d5a3b99077&X-Amz-SignedHeaders=host%3Bx-amz-server-side-encryption-customer-algorithm&x-amz-server-side-encryption-customer-algorithm=AES256');
      });
      it('gets a signed URL for putObject with a sse-c key', function() {
        var url;
        s3 = new AWS.S3({
          signatureVersion: 'v4'
        });
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'key',
          SSECustomerAlgorithm: 'AES256',
          SSECustomerKey: 'c2FtcGxlIGtleXNhbXBsZSBrZXlzYW1wbGUga2V5c2E='
        });
        return expect(url).to.equal('https://bucket.s3.mock-region.amazonaws.com/key?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=akid%2F19700101%2Fmock-region%2Fs3%2Faws4_request&X-Amz-Date=19700101T000000Z&X-Amz-Expires=900&X-Amz-Security-Token=session&X-Amz-Signature=e4f57734798fdadc0b2b43ca5a5e1f28824786c3ac74c30d7abb77d6ef59b0da&X-Amz-SignedHeaders=host%3Bx-amz-server-side-encryption-customer-algorithm%3Bx-amz-server-side-encryption-customer-key%3Bx-amz-server-side-encryption-customer-key-md5&x-amz-server-side-encryption-customer-algorithm=AES256&x-amz-server-side-encryption-customer-key=YzJGdGNHeGxJR3RsZVhOaGJYQnNaU0JyWlhsellXMXdiR1VnYTJWNWMyRT0%3D&x-amz-server-side-encryption-customer-key-MD5=VzaXhwL7H9upBc%2Fb9UqH8g%3D%3D');
      });
      it('gets a signed URL for putObject with CacheControl', function() {
        var url;
        s3 = new AWS.S3({
          signatureVersion: 'v4'
        });
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'key',
          CacheControl: 'max-age=10000'
        });
        return expect(url).to.equal('https://bucket.s3.mock-region.amazonaws.com/key?Cache-Control=max-age%3D10000&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=akid%2F19700101%2Fmock-region%2Fs3%2Faws4_request&X-Amz-Date=19700101T000000Z&X-Amz-Expires=900&X-Amz-Security-Token=session&X-Amz-Signature=39ad1f8dc3aa377c2b184a0be7657dfb606628c74796c1a48394ef134ff6233a&X-Amz-SignedHeaders=cache-control%3Bhost');
      });
      it('gets a signed URL and appends to existing query parameters', function() {
        var url;
        url = s3.getSignedUrl('listObjects', {
          Bucket: 'bucket',
          Prefix: 'prefix'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/?AWSAccessKeyId=akid&Expires=900&Signature=8W3pwZPfgucCyPNg1MsoYq8h5zw%3D&prefix=prefix&x-amz-security-token=session');
      });
      it('gets a signed URL for getObject using SigV4', function() {
        var url;
        s3 = new AWS.S3({
          signatureVersion: 'v4',
          region: void 0
        });
        url = s3.getSignedUrl('getObject', {
          Bucket: 'bucket',
          Key: 'object'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/object?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=akid%2F19700101%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=19700101T000000Z&X-Amz-Expires=900&X-Amz-Security-Token=session&X-Amz-Signature=05ae40d2d22c93549a1de0686232ff56baf556876ec497d0d8349431f98b8dfe&X-Amz-SignedHeaders=host');
      });
      it('gets a signed URL for putObject using SigV4', function() {
        var url;
        s3 = new AWS.S3({
          signatureVersion: 'v4',
          region: void 0
        });
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'object'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/object?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=akid%2F19700101%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=19700101T000000Z&X-Amz-Expires=900&X-Amz-Security-Token=session&X-Amz-Signature=1b6f75301a2e480bcfbb53d47d8940c28c8657ea70f23c24846a5595a53b1dfe&X-Amz-SignedHeaders=host');
      });
      it('gets a signed URL for putObject using SigV4 with body', function() {
        var url;
        s3 = new AWS.S3({
          signatureVersion: 'v4',
          region: void 0
        });
        url = s3.getSignedUrl('putObject', {
          Bucket: 'bucket',
          Key: 'object',
          Body: 'foo'
        });
        return expect(url).to.equal('https://bucket.s3.amazonaws.com/object?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae&X-Amz-Credential=akid%2F19700101%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=19700101T000000Z&X-Amz-Expires=900&X-Amz-Security-Token=session&X-Amz-Signature=600a64aff20c4ea6c28d11fd0639fb33a0107d072f4c2dd1ea38a16d057513f3&X-Amz-SignedHeaders=host%3Bx-amz-content-sha256');
      });
      it('errors when expiry time is greater than a week out on SigV4', function(done) {
        var data, err, error, params;
        err = null;
        data = null;
        s3 = new AWS.S3({
          signatureVersion: 'v4',
          region: void 0
        });
        params = {
          Bucket: 'bucket',
          Key: 'object',
          Expires: 60 * 60 * 24 * 7 + 120
        };
        error = 'Presigning does not support expiry time greater than a week with SigV4 signing.';
        return s3.getSignedUrl('getObject', params, function(err, data) {
          expect(err).not.to.equal(null);
          expect(err.message).to.equal(error);
          return done();
        });
      });
      return it('errors if ContentLength is passed as parameter', function() {
        return expect(function() {
          return s3.getSignedUrl('putObject', {
            Bucket: 'bucket',
            Key: 'key',
            ContentLength: 5
          });
        }).to["throw"](/ContentLength is not supported in pre-signed URLs/);
      });
    });
    describe('createPresignedPost', function() {
      it('should include a url and a hash of form fields', function(done) {
        s3 = new AWS.S3();
        return s3.createPresignedPost({
          Bucket: 'bucket'
        }, function(err, data) {
          expect(data).to.include.keys('fields', 'url');
          expect(data.url).to.be.a.string;
          expect(data.fields).to.be.an.object;
          return done();
        });
      });
      it('should include a policy, signature, and signing metadata', function(done) {
        s3 = new AWS.S3();
        return s3.createPresignedPost({
          Bucket: 'bucket'
        }, function(err, data) {
          expect(data.fields).to.include.keys('Policy', 'X-Amz-Signature', 'X-Amz-Algorithm', 'X-Amz-Date', 'X-Amz-Credential');
          return done();
        });
      });
      it('should specify the signing algorithm used', function(done) {
        s3 = new AWS.S3();
        return s3.createPresignedPost({
          Bucket: 'bucket'
        }, function(err, data) {
          expect(data.fields['X-Amz-Algorithm']).to.equal('AWS4-HMAC-SHA256');
          return done();
        });
      });
      it('should use bound parameters for the bucket name', function(done) {
        s3 = new AWS.S3({
          params: {
            Bucket: 'bucket'
          }
        });
        return s3.createPresignedPost({}, function(err, data) {
          expect(data.fields).to.include.keys('bucket');
          expect(data.fields.bucket).to.equal('bucket');
          return done();
        });
      });
      it('should include the security token when present', function(done) {
        var credentials, token;
        token = 'baz';
        credentials = {
          accessKeyId: 'foo',
          secretAccessKey: 'bar',
          sessionToken: token
        };
        s3 = new AWS.S3({
          credentials: credentials
        });
        return s3.createPresignedPost({
          Bucket: 'bucket'
        }, function(err, data) {
          expect(data.fields['X-Amz-Security-Token']).to.equal(token);
          return done();
        });
      });
      it('should provide a base64-encoded JSON policy document', function(done) {
        s3 = new AWS.S3();
        return s3.createPresignedPost({
          Bucket: 'bucket'
        }, function(err, data) {
          var decoded;
          decoded = JSON.parse(AWS.util.base64.decode(data.fields.Policy));
          expect(decoded).to.be.an.object;
          expect(decoded).to.include.key('expiration', 'conditions');
          return done();
        });
      });
      it('should default to expiration in one hour', function(done) {
        helpers.spyOn(AWS.util.date, 'getDate').andReturn(new Date(946684800 * 1000));
        s3 = new AWS.S3();
        return s3.createPresignedPost({
          Bucket: 'bucket'
        }, function(err, data) {
          var decoded;
          decoded = JSON.parse(AWS.util.base64.decode(data.fields.Policy));
          expect(decoded.expiration).to.equal('2000-01-01T01:00:00Z');
          return done();
        });
      });
      it('should allow users to provide a custom expiration', function(done) {
        var customTtl;
        helpers.spyOn(AWS.util.date, 'getDate').andReturn(new Date(946684800 * 1000));
        customTtl = 900;
        s3 = new AWS.S3();
        return s3.createPresignedPost({
          Bucket: 'bucket',
          Expires: customTtl
        }, function(err, data) {
          var decoded;
          decoded = JSON.parse(AWS.util.base64.decode(data.fields.Policy));
          expect(decoded.expiration).to.equal('2000-01-01T00:15:00Z');
          return done();
        });
      });
      it('should include signature metadata as conditions', function(done) {
        s3 = new AWS.S3();
        return s3.createPresignedPost({
          Bucket: 'bucket'
        }, function(err, data) {
          var condition, conditionKey, decoded, found, index, ref;
          decoded = JSON.parse(AWS.util.base64.decode(data.fields.Policy));
          expect(decoded.conditions).to.be.an.array;
          found = {};
          ref = decoded.conditions;
          for (index in ref) {
            condition = ref[index];
            conditionKey = Object.keys(condition)[0];
            found[conditionKey] = true;
            expect(condition[conditionKey]).to.equal(data.fields[conditionKey]);
          }
          expect(found['X-Amz-Algorithm']).to.be["true"];
          expect(found['X-Amz-Date']).to.be["true"];
          expect(found['X-Amz-Credential']).to.be["true"];
          return done();
        });
      });
      it('should include user-provided conditions in the signed policy', function(done) {
        var conditions;
        s3 = new AWS.S3();
        conditions = [
          {
            'x-amz-server-side-encryption': 'AES256'
          }, ['starts-with', '$x-amz-meta-tag', ''], {
            'acl': 'public-read'
          }
        ];
        return s3.createPresignedPost({
          Bucket: 'bucket',
          Conditions: conditions
        }, function(err, data) {
          var decoded;
          decoded = JSON.parse(AWS.util.base64.decode(data.fields.Policy));
          expect(decoded.conditions).to.be.an.array;
          expect(conditions[0]).to.deep.equal(decoded.conditions[0]);
          expect(conditions[1]).to.deep.equal(decoded.conditions[1]);
          expect(conditions[2]).to.deep.equal(decoded.conditions[2]);
          return done();
        });
      });
      return it('should include user-provided fields as policy conditions', function(done) {
        var fieldsToInclude;
        s3 = new AWS.S3();
        fieldsToInclude = {
          key: 'users/userId/upload',
          acl: 'public-read',
          'Content-Type': 'image/jpeg',
          'x-amz-meta-foo': 'bar',
          'x-amz-tagging': '<Tagging>\n  <TagSet>\n    <Tag>\n      <Key>foo</Key>\n      <Value>bar</Value>\n    </Tag>\n  </TagSet>\n</Tagging>'
        };
        return s3.createPresignedPost({
          Bucket: 'bucket',
          Fields: fieldsToInclude
        }, function(err, data) {
          var conditions, decoded;
          decoded = JSON.parse(AWS.util.base64.decode(data.fields.Policy));
          conditions = {};
          decoded.conditions.forEach(function(condition) {
            var conditionKey;
            if (typeof condition === 'object') {
              conditionKey = Object.keys(condition)[0];
              return conditions[conditionKey] = condition[conditionKey];
            }
          });
          Object.keys(fieldsToInclude).forEach(function(key) {
            expect(data.fields[key]).to.equal(fieldsToInclude[key]);
            return expect(data.fields[key]).to.equal(conditions[key]);
          });
          return done();
        });
      });
    });
    return describe('getBucketPolicy', function() {
      return it('converts the body to a string', function(done) {
        var body, policy;
        policy = JSON.stringify({
          key: 'value',
          foo: 'bar',
          fizz: 1
        });
        body = new Buffer(policy);
        helpers.mockHttpResponse(200, {}, body);
        return s3.getBucketPolicy(function(err, data) {
          expect(Buffer.isBuffer(data.Policy)).to.be["false"];
          expect(data.Policy).to.eql(policy);
          return done();
        });
      });
    });
  });

}).call(this);
